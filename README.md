This is a fun little experiment I'm doing to build a lightweight Mokito inspired mocking library.

For now it's functional and allows you to mock out methods by returning custom values,
executing a custom function, or throwing a custom exception as well as a custom error message.

This is a work in progress and is subject to change completely. If you come across this package, I suggest
you don't use it in production yet.

# Philosophy

DISCLAIMER: I'm trying to keep this library as lightweight as possible. I'm not trying to support every feature of Mokito. I just want to get the basics working.

The idea behind this library is to provide a simple way to mock dependencies in your code. I'm a big fan of dependency injection as a way to write testable code.

Sadly, I found the mocking ecosystem either too heavy (like the great `ts-mockito` package, sadly it seems it's not maintained that much anymore) or too framework specific (like `jest` utilities like `mockImplementationOnce`, `mockReturnValueOnce`, `fn()`, `spyOn()`, etc.);

I wanted something that was lightweight and easy to use.

# Mocks

Our mocks are generated by passing a class to the `mock` function. This will return an instance of the Mock class, camouflaged as the class you passed in.

```ts
import { Mockit } from "@vdcode/mockit";

class MyClass {
  public sum(a: number, b: number): number {
    return a + b;
  }

  public multiply(a: number, b: number): number {
    return a * b;
  }

  public async asyncSum(a: number, b: number): Promise<number> {
    return a + b;
  }
}

const myClassMock = Mockit.mock(MyClass);
```

**Mockit** allows you to change the behaviour of each function of your mock. Thanks to generics, you have access to auto-complete of the functions of your original class, which is very convenient.

```ts
// replace the returned value
Mockit.when(myClassMock).calls("sum", [1, 2]).thenReturns(3);

// throw instead
Mockit.when(myClassMock)
  .calls("sum", [1, 2])
  .thenThrows(new Error("Something went wrong"));

// execute a custom function
Mockit.when(myClassMock)
  .calls("sum", [1, 2])
  .thenCall((a, b) => a - b);

// resolve asynchronously
Mockit.when(myClassMock).calls("asyncSum", [1, 2]).thenResolve(3);

// reject asynchronously
Mockit.when(myClassMock)
  .calls("asyncSum", [1, 2])
  .thenReject(new Error("Something went wrong"));
```

# Spies

## Raw

**Mockit** also allows you to spy on the calls of your mock.

```ts
const mock = Mockit.mock(MyClass);
// register the the mock to the spy
const spy = Mockit.spy(myClassMock);

Mockit.when(myClassMock).calls("sum", [1, 2]).thenReturns(33);
Mockit.when(myClassMock).calls("sum", [2, 3]).thenReturns(15);

// call the function
myClassMock.sum(1, 2);
myClassMock.sum(2, 3);

// get the all the calls
const calls = spy.callsTo("sum").inTotal();

// get the calls with specific arguments
const callsFor1And2 = spy.callsTo("sum").withArgs([1, 2]);
```

These calls are objects of type Call.

```ts
export type Call = {
  args: any[];
  key: string;
  date: string; // ISO string
  mockedBehaviour: Function; // the mocked behaviour
  previousCalls: Call[];
};
```

You can use these calls for analysis, or to check that you mocked corretly with the `mockedBehaviour` key, which is effectively the mock you set up beforehand.

## Helpers

**Mockit** also provides a few helpers to make your life easier.

```ts
// These methods are syntactic sugar on top of the previously described methods.
spy.method("sum").hasBeenCalled();
spy.method("sum").hasBeenCalledWith([1, 2]);
spy.method("sum").hasBeenCalledTimes(2);
spy.method("sum").hasBeenCalledOnce();
```

With these helpers, you can pass around spies of individual methods.

```ts
const spy = Mockit.spy(myClassMock);
const sumSpy = spy.method("sum"); // this will... spy on the sum method
```

Once registered, you can keep using the spy

```ts
const spy = Mockit.spy(myClassMock);
const sumSpy = spy.method("sum");

Mockit.when(myClassMock).calls("sum", [1, 2]).thenReturns(33);

myClassMock.sum(1, 2);

sumSpy.hasBeenCalledOnce();

myClassMock.sum(1, 2);

// Sumspy gets updated with the new call data
sumSpy.hasBeenCalledTimes(2);
```

# Stubs

Sometimes, you just want to mock a class without having to mock each of its methods. **Mockit** provides a `stub` function to do just that.

Default behaviour is a stub whose functions will return nothing.

```ts
const myClassMock = Mockit.stub(MyClass);
myClassMock.sum(1, 2); // returns undefined
```

You can also specify a custom behaviour to the stub.

```ts
// Will return a specific value
Mockit.stubThatReturns(MyClass, 42);

// Will throw anything you pass in
Mockit.stubThatThrows(MyClass, new Error("Something went wrong"));

// Will execute a custom function
Mockit.stubThatCalls(MyClass, (a, b) => a - b);

// Will resolve asynchronously
Mockit.stubThatResolves(MyClass, 42);

// Will reject asynchronously
Mockit.stubThatRejects(MyClass, new Error("Something went wrong"));
```

These stubs cannot be spied on, but they're useful when you just want basic mocking injection.
